Basics:
	A game starring the characters from MW:ADC. Kind of a cross between an RPG and an adventure game.
	Also developing a core system that can be reused in other games.



TODO:
	DoneThisCommit:
		Implemented Controller and ControlledObject classes (along with a switch and door for the demo).  Also added animation and ability to embed AngelScript in XML files.
	Current Task:
		Implement Controller and ControlledObject classes, as well as a switch and door for the demo level.
	Next Steps:
		Clean up.
			Unnecessary includes
			Remove physics stuff from Projectile.
			Move functions in AngelScriptEngine.h to the cpp file.
			Change AngelScriptEngine execution methods such that they call runFunction(asIScriptFunction* func) instead of reimplementing the same code everywhere.
			Clean up the Controller and ControlledObject classes (a lot of code changes... they've become a bit of a mess.)
		Begin work on level editor.
		Flame jets for the demo level.


	Objects:
		Controllers and ControlledObjects--eg light switch and lamp, or switch and door.
			ControlledObject should use a FSM
		Some mechanism by which you can easily move between a set list of places (teleportation, taxicab, etc.). Long glides, jumps, etc. may leave you stranded otherwise.
		Figure out how best to use AngelScript to specify object behavior (AngelScript class cannot inherit a C++ class, so it's not that simple.)
	Scripting:
		Add ability to load (not run) an AngelScript file, adding functions, variables, object types, etc to the current context/module.
			Can use the CompileFunction and CompileGlobalVar functions to add functions and variables.
	AI:
		Enemies need more intelligent behavior (e.g. dodge)
	Stuff for first playable
	Input:
		Should be able to register a function to be executed on key press/release. Function will likely be in AngelScript.
	Use a game clock that's separate from the real-time clock. For debugging purposes. Allows to run the game in slow/fast motion.
	Development cheats and features:
		Changing game speed
	Level should contain lighting, enemies, and other things that would be in the scene.
	Physics fixes:
		figure out proper collision filtering technique for ghost objects (there should be no collision response, but it still needs to be detected.)
	Make sure it all works on Windows (with the exception of the extra mouse button support I added)
	Clean up:


Extras (if I get bored):
	SVG support.
	Physics:
		(2D) Should have two collision categories for obstacles: ground-level and body-level. Projectiles will be stopped by body-level obstacles (e.g. trees), but not ground-level (e.g. water).

BUGS:
	input handler does not respond to releasing a key if Ctrl is pressed. Most likely due to the way OSG reports the button. I think it's a different value if a modkey is pressed.
	The ghost object for the switch stops the player's movement.
	Console does not appear until window is resized
	Weapons do not point in the correct direction (rotated relative to the owner)
	Lighting needs work. Should figure out how to ensure every surface is lit.
	Collision checking (in Level) may call onCollision() multiple times for the same pair of objects if they have multiple manifolds, or if Bullet takes multiple simulation steps for one rendering step.
	Doors open, but do not close (not sure how to have multiple animations in Bullet, so currently they can have an open animation or a closing animation, but not both.)
	2D Stuff:
		TiledMap does not account for maps with multiple tilesets.
		Seg faults if the Box2D debug drawer sets the data variance to "dynamic"

Bugs I expect to see later:
	The functions specified in the XML files may cause issues once I have multiple objects of the same type (e.g. two kinds of ControlledObject), because they might override one another.

Issues: (with other software)
	TinyXML returns text as if it were all in one line, which causes issues when the text is AngelScript with comments (a single-line comment comments out the rest of the program).
	Not sure how to have multiple animations on an object in Blender. See http://wiki.blender.org/index.php/Doc:2.6/Manual/Animation/Basics/Actions

Things to remember to prevent bugs:
	It is NOT safe to alter the scene graph during a traversal (multi-threaded, multiple traversals happen at the same time). To ensure that doesn't happen, use the addToSceneGraph function for any new nodes, rather than adding them directly.
	TinyXML returns text as if it were all in one line, which causes issues when the text is AngelScript with comments (a single-line comment comments out the rest of the program).


Things to consider:
	Check out AngelScript/sdk/samples/game. Uses a "controller" class to control game objects. Might be a useful approach.


Useful notes:
	Entity systems:
		Rationalization for entities instead of traditional class-based system is that in most applications, the behavior of objects doesn't change, but in games, an object could change roles (e.g. an enemy is stunned and no longer attacks). An entity-component system allows behavior to be changed during runtime simply by adding and removing components.

Scripting Uses:
	Input?--so that options can be set more easily. In addition to the standard key bindings, it'll also be possible to define custom controls that depend on more than a single binding.
	AI
	Testing purposes.
	"You want to expose capable, but soulless actors to your scripting code. The scripting code describes what the actors should do, but the C++ code takes care of the how."	-- http://stackoverflow.com/questions/609076/the-role-of-scripting-languages-in-game-programming

Expose to scripting:
	Camera control?--For cutscenes
	The basics: enemies, player, et cetera


Engine features:
	Adaptive. Designed to minimize the amount of custom code that must be written.
	Objects are defined with XML.
		Can embed in the level file, link to an external file, or both (using external file as prototype and making necessary alterations in the level file).
			Can also define an object using another as a prototype (e.g. multiple versions of an enemy use a common base).
		Can embed AngelScript inside the XML file, further increasing adaptability.
			Can attach functions to an object, to be used elsewhere (e.g. a door has the functions "open()" and "close()" defined in a central location, and called in response to signals from a switch.)


Multiple playable characters:
	I'll likely be working on this thing for a long time, so I'd like to be able to put all my main characters in it. Show off my best character-creation and dialog skills. And just enjoy it more.
	Each character is unique. They all have their own powers, and even different play experiences.
		Luce:
			After doing something really awful, everyone insists he gets a morality meter. Which he does. It ranges from blue to orange.
			Sees extended information on enemies.
			Has hallucinations.
			Can drive people insane by showing them The Truth.
			Entertaining dialog options.
			Has lots of useful knowledge (codes and passwords), which he will only use after having enough "fun". Basically, you need to be sadistic in order to use his abilities. There's almost always some option to torture someone, though, so there's not a large effect on gameplay.
		Alex:
			Breathes fire.
			Immune to fire.
			Healing.
		Tanner:
			Adorable.
			Can nap to recover energy.
			Kittenriffic.
	Probably a good idea. Even if it doesn't work for the final game, it will allow me to experiment with all the characters, and see who people like playing as.


Goals:
	First playable-- demo level with basic functionality.
		Functionality:
			Combat-- GOT IT!!
			Weapon system
			Basic enemy AI-- look for the player, and try to kill him.
			Scripting--DONE!! (or close enough)
			Physics
		Assets:
			Enemies-- at least two types.
			A few standin models.
			Basic level, with at least one puzzle
				Puzzle idea: hallway full of flame jets, Alex needs to go through and activate some switch to open a door for the others. Unfortunately, the switch also locked him inside the room, and the others need to find a switch to free him.


Stuff Learned:
	Tile maps:
		To avoid bad edges, set filtering to "Nearest", meaning that GL shouldn't try any antialiasing.
