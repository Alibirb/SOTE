Basics:
	Action-adventure game. Also developing a core system that can be reused in other games.

Plot: (this is long-winded right now)
	An alien ship crashed on Earth (or the alien landed safely, and something happened to them later.) The alien's body was destroyed, but they survived inside a backup device. The device is intended solely for transferring to a new body, and isn't a suitable long-term solution. Someone eventually discovered the alien, though, and managed to establish communications with them. The alien's species has discovered methods to combine magic and electronics/computers, but insists on a suitable replacement body before sharing anything. The ideal body is one of a living child. Dead bodies are tough to reanimate (and tend to be of bad quality), and adult bodies have finished growing, so they're harder to adapt. So, the guy that found the alien kidnaps some kids and offers them up("How can we pass up this opportunity? Surely one child is an acceptable sacrifice for this kind of knowledge"). The alien picks one, begins the transfer process... and then nothing. The child wakes up again, no trace of the alien's mind. Nobody's sure whether they can safely remove the transfer device, and the kid runs away before they can do anything, anyway.
	As it turns out, the process failed because the body was already occupied. The alien failed to realize that the people of Earth lack the ability to grow uninhabited bodies. So the two minds merged, creating a new one. Half alien, half human (or some other species). This new mind is Zack.
	Zack isn't exactly human, or alien. His mind is a blending of the two, and his body--though originally human (or whatever species)--soon changes, adapts to become what he wants. And he has the knowledge of the alien, the secret to combining magic and conventional technology.

TODO:
	Next Step: add scripting console. Currently trying to figure out how to rotate weapons properly, and being able to try out different rotations would be very useful.


	Physics:
		Improve integration with OSG.
		Character controller
	Stuff for first playable
	Add AngelScript scripting--		NOW!! So I can set up a startup script to run for testing purposes.
		AngelScript seems like the best solution. For one thing, it's strongly typed and has a C-like syntax, so there's familiarity. Should also be easier. It was designed to integrate well with C++, and you don't need to do much extra work to expose C++ functions to AngelScript, which is pretty essential if I want the flexibility to code with either language. Can use C++ for core functionality, and run scripts where necessary for anything that's likely to change (eg AI).
	Cleanup:
		Header files should only contain the declarations.
	Input:
		Should be able to register a function to be executed on key press/release. Function will likely be in AngelScript.
	Use a game clock that's separate from the real-time clock. For debugging purposes. Allows to run the game in slow/fast motion.
	Development cheats and features:
		Teleportation
		Changing game speed

BUGS:
	input handler does not respond to releasing a key if Ctrl is pressed. Most likely due to the way OSG reports the button. I think it's a different value if a modkey is pressed.
	Seg faults upon closing. See the two forum threads in Firefox.
	Seg faults if too many physcis objects are created
	Seg faults if the debug drawer sets the data variance to "dynamic"


Useful notes:
	Entity systems:
		Rationalization for entities instead of traditional class-based system is that in most applications, the behavior of objects doesn't change, but in games, an object could change roles (e.g. an enemy is stunned and no longer attacks). An entity-component system allows behavior to be changed during runtime simply by adding and removing components.

Scripting Uses:
	Input-- so that options can be set more easily. In addition to the standard key bindings, it'll also be possible to define custom controls that depend on more than a single binding.
	AI?
	Weapons/attacks/enemies
	Main usage is for me, but there may be some things that players will want to customize. Granted, using AngelScript makes it a bit more difficult for non-programmers, but honestly, nobody's gonna get this game, anyway.
	"you want to expose capable, but soulless actors to your scripting code. The scripting code describes what the actors should do, but the C++ code takes care of the how."	-- http://stackoverflow.com/questions/609076/the-role-of-scripting-languages-in-game-programming

Expose to scripting:
	Camera control?--For cutscenes
	The basics: enemies, player, et cetera


Innovative combat system:
	Rather than simply hand the player a bunch of weapons, you're given tools to make your own. You get various weapon bodies that you add some kind of magic power source to, and it creates an elemental weapon. A lot of enemies have some sort of immunity, so you need to think about what attack you use. Often, attacks must be chained, e.g. freeze the enemy, then shatter them.
	Not sure how far to go with this. Could just have body + magic = weapon, or could provide a more flexible system that allows people to experiment and design new weapons, controlling not just element and weapon type, but properties like fire rate, power, etc. For example, you might be able to alter the component that interacts with the magic power source, and overclock it to get more power or faster firing. I think it could be a pretty awesome system.
	Power sources:
		Phoenix feather-- Fire. Also good for healing.


Goals:
	First playable-- demo level with basic functionality.
		Functionality:
			Combat
			Weapon system
			Basic enemy AI-- look for the player, and try to kill him.
			Tilemap rendering-- DONE!!!
			Scripting?-- Eventually, enemies are probably going to use scripting, so depending on how advanced I make the first playable enemies, I may want to implement scripting as part of this phase.
			Physics
		Assets:
			Enemies-- at least two types, killed in different ways
			Weapons-- at least one body, at least two power sources.
			Player sprite
			Basic tilemap


Stuff Learned:
	Tile maps:
		To avoid bad edges, set filtering to "Nearest", meaning that GL shouldn't try any antialiasing.
